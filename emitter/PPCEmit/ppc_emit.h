//--nullDCe PPC Emitter--
//Generated by PPCOpcodeGrabber @ 16/10/2009
//THIS FILE IS AUTOGENERATED, PLEASE SAVE YOUR TIME
//AND EDIT THE C# GENERATOR INSTEAD !

//Emits a ppc opcode (you'l have to supply this)
extern void ppc_emit(u32 insn);


//addx,011111,D<5>,A<5>,B<5>,OE<1>,100001010,Rc<1>

//Add
//rD = (rA) + (rB)
static inline void ppc_addx(u32 D,u32 A,u32 B,u32 OE,u32 Rc)
{
	ppc_emit( 0x7c000214 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)OE)<<10) | ((0x1 & (u32)Rc)<<0) );
}


//addcx,011111,D<5>,A<5>,B<5>,OE<1>,000001010,Rc<1>

//Add Carrying (carry out)
//rD = (rA) + (rB)
static inline void ppc_addcx(u32 D,u32 A,u32 B,u32 OE,u32 Rc)
{
	ppc_emit( 0x7c000014 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)OE)<<10) | ((0x1 & (u32)Rc)<<0) );
}


//addex,011111,D<5>,A<5>,B<5>,OE<1>,010001010,Rc<1>

//Add Extended (carry-in-out)
//rD = (rA) + (rB) + XER[CA]
static inline void ppc_addex(u32 D,u32 A,u32 B,u32 OE,u32 Rc)
{
	ppc_emit( 0x7c000114 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)OE)<<10) | ((0x1 & (u32)Rc)<<0) );
}


//addi,001110,D<5>,A<5>,SIMM<16>

//Add Immediate
//rD = (rA|0) + EXTS(SIMM)
static inline void ppc_addi(u32 D,u32 A,u32 SIMM)
{
	ppc_emit( 0x38000000 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0xffff & (u32)SIMM)<<0) );
}


//addic,00110,_Rc<1>_,D<5>,A<5>,SIMM<16>

//Add Immediate Carrying
//rD = (rA) + EXTS(SIMM)
static inline void ppc_addic(u32 D,u32 A,u32 SIMM,u32 Rc)
{
	ppc_emit( 0x30000000 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0xffff & (u32)SIMM)<<0) | ((0x1 & (u32)Rc)<<26) );
}


//addis,001111,D<5>,A<5>,SIMM<16>

//Add Immediate Shifted
//rD = (rA|0) + (SIMM <<16)
static inline void ppc_addis(u32 D,u32 A,u32 SIMM)
{
	ppc_emit( 0x3c000000 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0xffff & (u32)SIMM)<<0) );
}


//addmex,011111,D<5>,A<5>,00000,OE<1>,011101010,Rc<1>

//Add to Minus One Extended
//rD = (rA) + XER[CA]  1
static inline void ppc_addmex(u32 D,u32 A,u32 OE,u32 Rc)
{
	ppc_emit( 0x7c0001d4 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1 & (u32)OE)<<10) | ((0x1 & (u32)Rc)<<0) );
}


//addzex,011111,D<5>,A<5>,00000,OE<1>,011001010,Rc<1>

//Add to Zero Extended
//rD = (rA) + XER[CA]
static inline void ppc_addzex(u32 D,u32 A,u32 OE,u32 Rc)
{
	ppc_emit( 0x7c000194 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1 & (u32)OE)<<10) | ((0x1 & (u32)Rc)<<0) );
}


//andx,011111,S<5>,A<5>,B<5>,0000011100,Rc<1>

//And
//rA = (rS) & (rB)
static inline void ppc_andx(u32 A,u32 S,u32 B,u32 Rc)
{
	ppc_emit( 0x7c000038 | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)Rc)<<0) );
}


//andcx,011111,S<5>,A<5>,B<5>,0000111100,Rc<1>

//AND with Complement
//rA = (rS) & ~ (rB)
static inline void ppc_andcx(u32 A,u32 S,u32 B,u32 Rc)
{
	ppc_emit( 0x7c000078 | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)Rc)<<0) );
}


//andi,011100,S<5>,A<5>,UIMM<16>

//And Immediate
//rA = (rS) & (UIMM), CR0 set
static inline void ppc_andi(u32 A,u32 S,u32 UIMM)
{
	ppc_emit( 0x70000000 | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)S)<<21) | ((0xffff & (u32)UIMM)<<0) );
}


//andis,011101,S<5>,A<5>,UIMM<16>

//And Immediate Shifted
//rA = (rS) & ( UIMM <<16 )
static inline void ppc_andis(u32 A,u32 S,u32 UIMM)
{
	ppc_emit( 0x74000000 | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)S)<<21) | ((0xffff & (u32)UIMM)<<0) );
}


//bx,010010,LI<24>,AA<1>,LK<1>

//Branch
//snat offs=EXTS(LI<<2);
//if (lk) lr=pc+4;
//if (aa==0) pc+=offs; else pc=offs;
static inline void ppc_bx(u32 LI,u32 AA,u32 LK)
{
	ppc_emit( 0x48000000 | ((0xffffff & (u32)LI)<<2) | ((0x1 & (u32)AA)<<1) | ((0x1 & (u32)LK)<<0) );
}


//bcx,010000,BO<5>,BI<5>,BD<14>,AA<1>,LK<1>

//Branch Conditional
//snat offs=EXTS(BD<<2);
//if (lk) lr=pc+4;
//if (aa==0) pc+=offs; else pc=offs;
static inline void ppc_bcx(u32 BO,u32 BI,u32 BD,u32 AA,u32 LK)
{
	ppc_emit( 0x40000000 | ((0x1f & (u32)BO)<<21) | ((0x1f & (u32)BI)<<16) | ((0x3fff & (u32)BD)<<2) | ((0x1 & (u32)AA)<<1) | ((0x1 & (u32)LK)<<0) );
}


//bcctrx,010011,BO<5>,BI<5>,000001000010000,LK<1>

//Branch Conditional to Count Register
//if (!cond(BO,BI)) continue;
//if (lk) lr=pc+4;
//pc=ctr;
static inline void ppc_bcctrx(u32 BO,u32 BI,u32 LK)
{
	ppc_emit( 0x4c000420 | ((0x1f & (u32)BO)<<21) | ((0x1f & (u32)BI)<<16) | ((0x1 & (u32)LK)<<0) );
}


//bclrx,010011,BO<5>,BI<5>,000000000010000,LK<1>

//Branch Conditional to Link Register
//if (!cond(BO,BI)) continue;
//if (lk) lr2'=pc+4;
//pc=lr;
//lr=lr2';
static inline void ppc_bclrx(u32 BO,u32 BI,u32 LK)
{
	ppc_emit( 0x4c000020 | ((0x1f & (u32)BO)<<21) | ((0x1f & (u32)BI)<<16) | ((0x1 & (u32)LK)<<0) );
}


//cmp,011111,crfD<3>,0,L<1>,A<5>,B<5>,00000000000

//Compare (L=0)
//CR[crfD]=cmp(A,B)
static inline void ppc_cmp(u32 crfD,u32 A,u32 B,u32 L)
{
	ppc_emit( 0x7c000000 | ((0x7 & (u32)crfD)<<23) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)L)<<21) );
}


//cmpi,001011,crfD<3>,0,L<1>,A<5>,SIMM<16>

//Compare Immediate (L=0)
//CR[crfD]=cmp(A,SIMM)
static inline void ppc_cmpi(u32 crfD,u32 A,u32 SIMM,u32 L)
{
	ppc_emit( 0x2c000000 | ((0x7 & (u32)crfD)<<23) | ((0x1f & (u32)A)<<16) | ((0xffff & (u32)SIMM)<<0) | ((0x1 & (u32)L)<<21) );
}


//cmpl,011111,crfD<3>,0,L<1>,A<5>,B<5>,00001000000

//Compare Logical (L=0)
//CR[crfD]=cmp unsigned (A,B)
static inline void ppc_cmpl(u32 crfD,u32 A,u32 B,u32 L)
{
	ppc_emit( 0x7c000040 | ((0x7 & (u32)crfD)<<23) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)L)<<21) );
}


//cmpli,001010,crfD<3>,0,L<1>,A<5>,UIMM<16>

//Compare Logical Immediate (L=0)
//CR[crfD]=cmp unsigned (A,UIMM)
static inline void ppc_cmpli(u32 crfD,u32 A,u32 UIMM,u32 L)
{
	ppc_emit( 0x28000000 | ((0x7 & (u32)crfD)<<23) | ((0x1f & (u32)A)<<16) | ((0xffff & (u32)UIMM)<<0) | ((0x1 & (u32)L)<<21) );
}


//cntlzwx,011111,S<5>,A<5>,000000000011010,Rc<1>

//Count Leading Zeros Word
//Returns 32 on 0
//rA=leading_zeros(rS)
static inline void ppc_cntlzwx(u32 A,u32 S,u32 Rc)
{
	ppc_emit( 0x7c000034 | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)S)<<21) | ((0x1 & (u32)Rc)<<0) );
}


//crand,010011,crbD<5>,crbA<5>,crbB<5>,01000000010

//Condition Register And
//CR[crbD] = CR[crbA] & CR[crbB]
static inline void ppc_crand(u32 crbD,u32 crbA,u32 crbB)
{
	ppc_emit( 0x4c000202 | ((0x1f & (u32)crbD)<<21) | ((0x1f & (u32)crbA)<<16) | ((0x1f & (u32)crbB)<<11) );
}


//crandc,010011,crbD<5>,crbA<5>,crbB<5>,00100000010

//Condition Register And with Complement
//CR[crbD] =  CR[crbA] & ~ CR[crbB]
static inline void ppc_crandc(u32 crbD,u32 crbA,u32 crbB)
{
	ppc_emit( 0x4c000102 | ((0x1f & (u32)crbD)<<21) | ((0x1f & (u32)crbA)<<16) | ((0x1f & (u32)crbB)<<11) );
}


//creqv,010011,crbD<5>,crbA<5>,crbB<5>,01001000010

//Condition Register Equivalent
//CR[crbD] = CR[crbA] == CR[crbB]
static inline void ppc_creqv(u32 crbD,u32 crbA,u32 crbB)
{
	ppc_emit( 0x4c000242 | ((0x1f & (u32)crbD)<<21) | ((0x1f & (u32)crbA)<<16) | ((0x1f & (u32)crbB)<<11) );
}


//crnand,010011,crbD<5>,crbA<5>,crbB<5>,00111000010

//Condition Register nand
//CR[crbD] = ~  (CR[crbA] & CR[crbB])
static inline void ppc_crnand(u32 crbD,u32 crbA,u32 crbB)
{
	ppc_emit( 0x4c0001c2 | ((0x1f & (u32)crbD)<<21) | ((0x1f & (u32)crbA)<<16) | ((0x1f & (u32)crbB)<<11) );
}


//crnor,010011,crbD<5>,crbA<5>,crbB<5>,00001000010

//Condition Register nor
//CR[crbD] = ~ (CR[crbA] | CR[crbB])
static inline void ppc_crnor(u32 crbD,u32 crbA,u32 crbB)
{
	ppc_emit( 0x4c000042 | ((0x1f & (u32)crbD)<<21) | ((0x1f & (u32)crbA)<<16) | ((0x1f & (u32)crbB)<<11) );
}


//cror,010011,crbD<5>,crbA<5>,crbB<5>,01110000010

//Condition Register Or
//CR[crbD] = CR[crbA] | CR[crbB]
static inline void ppc_cror(u32 crbD,u32 crbA,u32 crbB)
{
	ppc_emit( 0x4c000382 | ((0x1f & (u32)crbD)<<21) | ((0x1f & (u32)crbA)<<16) | ((0x1f & (u32)crbB)<<11) );
}


//crorc,010011,crbD<5>,crbA<5>,crbB<5>,01101000010

//Condition Register OR with Complement
//CR[crbD] = CR[crbA] | ~ CR[crbB]
static inline void ppc_crorc(u32 crbD,u32 crbA,u32 crbB)
{
	ppc_emit( 0x4c000342 | ((0x1f & (u32)crbD)<<21) | ((0x1f & (u32)crbA)<<16) | ((0x1f & (u32)crbB)<<11) );
}


//crxor,010011,crbD<5>,crbA<5>,crbB<5>,00110000010

//Condition Register Xor
//CR[crbD] = CR[crbA] ^ CR[crbB]
static inline void ppc_crxor(u32 crbD,u32 crbA,u32 crbB)
{
	ppc_emit( 0x4c000182 | ((0x1f & (u32)crbD)<<21) | ((0x1f & (u32)crbA)<<16) | ((0x1f & (u32)crbB)<<11) );
}


//dcbf,01111100000,A<5>,B<5>,00010101100

//Data Cache Block Flush
//EA is the sum (rA|0) + (rB)
static inline void ppc_dcbf(u32 A,u32 B)
{
	ppc_emit( 0x7c0000ac | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//dcbi,01111100000,A<5>,B<5>,01110101100

//Data Cache Block Invalidate
//EA is the sum (rA|0) + (rB)
static inline void ppc_dcbi(u32 A,u32 B)
{
	ppc_emit( 0x7c0003ac | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//dcbst,01111100000,A<5>,B<5>,00001101100

//Data Cache Block Store
//EA is the sum (rA|0) + (rB)
static inline void ppc_dcbst(u32 A,u32 B)
{
	ppc_emit( 0x7c00006c | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//dcbt,01111100000,A<5>,B<5>,01000101100

//Data Cache Block Touch
//EA is the sum (rA|0) + (rB)
static inline void ppc_dcbt(u32 A,u32 B)
{
	ppc_emit( 0x7c00022c | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//dcbtst,01111100000,A<5>,B<5>,00111101100

//Data Cache Block Touch for Store
//EA is the sum (rA|0) + (rB)
static inline void ppc_dcbtst(u32 A,u32 B)
{
	ppc_emit( 0x7c0001ec | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//dcbz_l,00010000000,A<5>,B<5>,11111101100

//Data Cache Block Set to Zero Locked
//EA is the sum (rA|0) + (rB)
static inline void ppc_dcbz_l(u32 A,u32 B)
{
	ppc_emit( 0x100007ec | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//dcbz,01111100000,A<5>,B<5>,11111101100

//Data Cache Block Clear to Zero
//EA is the sum (rA|0) + (rB)
static inline void ppc_dcbz(u32 A,u32 B)
{
	ppc_emit( 0x7c0007ec | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//divwx,011111,D<5>,A<5>,B<5>,OE<1>,111101011,Rc<1>

//Divide Word 
//rD = signed(rA) / signed(rB)
static inline void ppc_divwx(u32 D,u32 A,u32 B,u32 OE,u32 Rc)
{
	ppc_emit( 0x7c0003d6 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)OE)<<10) | ((0x1 & (u32)Rc)<<0) );
}


//divwux,011111,D<5>,A<5>,B<5>,OE<1>,111001011,Rc<1>

//Divide Word Unsigned
//rD = unsigned(rA) / unsigned(rB)
static inline void ppc_divwux(u32 D,u32 A,u32 B,u32 OE,u32 Rc)
{
	ppc_emit( 0x7c000396 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)OE)<<10) | ((0x1 & (u32)Rc)<<0) );
}


//eciwx,011111,D<5>,A<5>,B<5>,01001101100

//External Control In Word Indexed
//EA is the sum (rA|0) + (rB)
static inline void ppc_eciwx(u32 D,u32 A,u32 B)
{
	ppc_emit( 0x7c00026c | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//ecowx,011111,S<5>,A<5>,B<5>,01101101100

//External Control Out Word Indexed
//EA is the sum (rA|0) + (rB)
static inline void ppc_ecowx(u32 S,u32 A,u32 B)
{
	ppc_emit( 0x7c00036c | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//eieio,01111100000000000000011010101100

//Enforce In-Order Execution of I/O
static inline void ppc_eieio()
{
	ppc_emit( 0x7c0006ac );
}


//eqvx,011111,S<5>,A<5>,B<5>,0100011100,Rc<1>

//Equivalent
//rA = ~ ((rS) ^ (rB))
static inline void ppc_eqvx(u32 A,u32 S,u32 B,u32 Rc)
{
	ppc_emit( 0x7c000238 | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)Rc)<<0) );
}


//extsbx,011111,S<5>,A<5>,000001110111010,Rc<1>

//Extend Sign Byte
//rA=(s8)rS
static inline void ppc_extsbx(u32 A,u32 S,u32 Rc)
{
	ppc_emit( 0x7c000774 | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)S)<<21) | ((0x1 & (u32)Rc)<<0) );
}


//extshx,011111,S<5>,A<5>,000001110011010,Rc<1>

//Extend Sign Half Word
//rA=(s16)rS
static inline void ppc_extshx(u32 A,u32 S,u32 Rc)
{
	ppc_emit( 0x7c000734 | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)S)<<21) | ((0x1 & (u32)Rc)<<0) );
}


//fabsx,111111,D<5>,00000,B<5>,0100001000,Rc<1>

//Floating Absolute Value
//frD=fabs(frB)
static inline void ppc_fabsx(u32 D,u32 B,u32 Rc)
{
	ppc_emit( 0xfc000210 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)Rc)<<0) );
}


//faddx,111111,D<5>,A<5>,B<5>,0000010101,Rc<1>

//Floating Add (Double-Precision)
//frD = frA + frB
static inline void ppc_faddx(u32 D,u32 A,u32 B,u32 Rc)
{
	ppc_emit( 0xfc00002a | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)Rc)<<0) );
}


//faddsx,111011,D<5>,A<5>,B<5>,0000010101,Rc<1>

//Floating Add Single
//if HID2[PSE] = 0
//  frD = frA + frB
//else 
//  frD(ps0) = frA(ps0) + frB(ps0)
//  frD(ps1) = frD(ps0)
static inline void ppc_faddsx(u32 D,u32 A,u32 B,u32 Rc)
{
	ppc_emit( 0xec00002a | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)Rc)<<0) );
}


//fcmpo,111111,crfD<3>,00,A<5>,B<5>,00001000000

//Floating Compare Ordered
//CR[crfD]=CmpOrdered(A,B)
static inline void ppc_fcmpo(u32 crfD,u32 A,u32 B)
{
	ppc_emit( 0xfc000040 | ((0x7 & (u32)crfD)<<23) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//fcmpu,111111,crfD<3>,00,A<5>,B<5>,00000000000

//Floating Compare Unordered
//CR[crfD]=CmpUnordered(A,B)
static inline void ppc_fcmpu(u32 crfD,u32 A,u32 B)
{
	ppc_emit( 0xfc000000 | ((0x7 & (u32)crfD)<<23) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//fctiwx,111111,D<5>,00000,B<5>,0000001110,Rc<1>

//Floating Convert to Integer Word
//frD=int_saturated(frB)
static inline void ppc_fctiwx(u32 D,u32 B,u32 Rc)
{
	ppc_emit( 0xfc00001c | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)Rc)<<0) );
}


//fctiwzx,111111,D<5>,00000,B<5>,0000001111,Rc<1>

//Floating Convert to Integer Word with Round toward Zero
//frD=int_saturated_zero(frB)
static inline void ppc_fctiwzx(u32 D,u32 B,u32 Rc)
{
	ppc_emit( 0xfc00001e | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)Rc)<<0) );
}


//fdivx,111111,D<5>,A<5>,B<5>,0000010010,Rc<1>

//Floaiting Divide (Double-Precision)
//frD=frA/frB
static inline void ppc_fdivx(u32 D,u32 A,u32 B,u32 Rc)
{
	ppc_emit( 0xfc000024 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)Rc)<<0) );
}


//fdivsx,111011,D<5>,A<5>,B<5>,0000010010,Rc<1>

//Floating Divide Single
//frD=frA/frB
static inline void ppc_fdivsx(u32 D,u32 A,u32 B,u32 Rc)
{
	ppc_emit( 0xec000024 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)Rc)<<0) );
}


//fmaddx,111111,D<5>,A<5>,B<5>,C<5>,11101,Rc<1>

//Floating Multiply-Add (Double-Precision)
//frD = (frA * frC) + frB
static inline void ppc_fmaddx(u32 D,u32 A,u32 B,u32 C,u32 Rc)
{
	ppc_emit( 0xfc00003a | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1f & (u32)C)<<6) | ((0x1 & (u32)Rc)<<0) );
}


//fmaddsx,111011,D<5>,A<5>,B<5>,C<5>,11101,Rc<1>

//Floating Multiply-Add Single
//frD = (frA * frC) + frB
static inline void ppc_fmaddsx(u32 D,u32 A,u32 B,u32 C,u32 Rc)
{
	ppc_emit( 0xec00003a | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1f & (u32)C)<<6) | ((0x1 & (u32)Rc)<<0) );
}


//fmrx,111111,D<5>,00000,B<5>,0001001000,Rc<1>

//Floating Move Register(Double-Precision)
//frD= frB
static inline void ppc_fmrx(u32 D,u32 B,u32 Rc)
{
	ppc_emit( 0xfc000090 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)Rc)<<0) );
}


//fmsubx,111111,D<5>,A<5>,B<5>,C<5>,11100,Rc<1>

//Floating Multiply-Subtract (Double-Precision)
//frD = [frA * frC] - frB
static inline void ppc_fmsubx(u32 D,u32 A,u32 B,u32 C,u32 Rc)
{
	ppc_emit( 0xfc000038 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1f & (u32)C)<<6) | ((0x1 & (u32)Rc)<<0) );
}


//fmsubsx,111011,D<5>,A<5>,B<5>,C<5>,11100,Rc<1>

//Floating Multiply-Subtract Single
//frD = [frA * frC] - frB
static inline void ppc_fmsubsx(u32 D,u32 A,u32 B,u32 C,u32 Rc)
{
	ppc_emit( 0xec000038 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1f & (u32)C)<<6) | ((0x1 & (u32)Rc)<<0) );
}


//fmulx,111111,D<5>,A<5>,00000,C<5>,11001,Rc<1>

//Floating Multiply (Double-Precision)
//frD = frA * frC
static inline void ppc_fmulx(u32 D,u32 A,u32 C,u32 Rc)
{
	ppc_emit( 0xfc000032 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)C)<<6) | ((0x1 & (u32)Rc)<<0) );
}


//fmulsx,111011,D<5>,A<5>,00000,C<5>,11001,Rc<1>

//frD = frA * frC
static inline void ppc_fmulsx(u32 D,u32 A,u32 C,u32 Rc)
{
	ppc_emit( 0xec000032 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)C)<<6) | ((0x1 & (u32)Rc)<<0) );
}


//fnabsx,111111,D<5>,00000,B<5>,0010001000,Rc<1>

//Floating Negative Absolute Value
//frD=-fabs(frB)
static inline void ppc_fnabsx(u32 D,u32 B,u32 Rc)
{
	ppc_emit( 0xfc000110 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)Rc)<<0) );
}


//fnegx,111111,D<5>,00000,B<5>,0000101000,Rc<1>

//Floating Negate
//frD=-frB
static inline void ppc_fnegx(u32 D,u32 B,u32 Rc)
{
	ppc_emit( 0xfc000050 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)Rc)<<0) );
}


//fnmaddx,111111,D<5>,A<5>,B<5>,C<5>,11111,Rc<1>

//Floating Negative Multiply-Add (Double-Precision)
//frD = - ([frA * frC] + frB)
static inline void ppc_fnmaddx(u32 D,u32 A,u32 B,u32 C,u32 Rc)
{
	ppc_emit( 0xfc00003e | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1f & (u32)C)<<6) | ((0x1 & (u32)Rc)<<0) );
}


//fnmaddsx,111011,D<5>,A<5>,B<5>,C<5>,11111,Rc<1>

//Floating Negative Multiply-Add Single
//frD = -([frA * frC] + frB)
static inline void ppc_fnmaddsx(u32 D,u32 A,u32 B,u32 C,u32 Rc)
{
	ppc_emit( 0xec00003e | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1f & (u32)C)<<6) | ((0x1 & (u32)Rc)<<0) );
}


//fnmsubx,111111,D<5>,A<5>,B<5>,C<5>,11110,Rc<1>

//Floating Negative Multiply-Subtract (Double-Precision)
//frD = - ([frA * frC] - frB)
static inline void ppc_fnmsubx(u32 D,u32 A,u32 B,u32 C,u32 Rc)
{
	ppc_emit( 0xfc00003c | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1f & (u32)C)<<6) | ((0x1 & (u32)Rc)<<0) );
}


//fnmsubsx,111011,D<5>,A<5>,B<5>,C<5>,11110,Rc<1>

//Floating Negative Multiply-Subtract Single
//frD = - ([frA * frC] - frB)
static inline void ppc_fnmsubsx(u32 D,u32 A,u32 B,u32 C,u32 Rc)
{
	ppc_emit( 0xec00003c | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1f & (u32)C)<<6) | ((0x1 & (u32)Rc)<<0) );
}


//fresx,111011,D<5>,00000,B<5>,0000011000,Rc<1>

//Floating Reciprocal Estimate Single
//frD = estimate(1/frB)
static inline void ppc_fresx(u32 D,u32 B,u32 Rc)
{
	ppc_emit( 0xec000030 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)Rc)<<0) );
}


//frspx,111111,D<5>,00000,B<5>,0000001100,Rc<1>

//Floating Round to Single
//frD=(f32)frB;
static inline void ppc_frspx(u32 D,u32 B,u32 Rc)
{
	ppc_emit( 0xfc000018 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)Rc)<<0) );
}


//frsqrtex,111111,D<5>,00000,B<5>,0000011010,Rc<1>

//Floating Reciprocal Square Root Estimate
//frD=approx(1/sqrt(frB))
static inline void ppc_frsqrtex(u32 D,u32 B,u32 Rc)
{
	ppc_emit( 0xfc000034 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)Rc)<<0) );
}


//fselx,111111,D<5>,A<5>,B<5>,C<5>,10111,Rc<1>

//Floating Select
//frD = frA>=0?frC:frB
static inline void ppc_fselx(u32 D,u32 A,u32 B,u32 C,u32 Rc)
{
	ppc_emit( 0xfc00002e | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1f & (u32)C)<<6) | ((0x1 & (u32)Rc)<<0) );
}


//fsubx,111111,D<5>,A<5>,B<5>,0000010100,Rc<1>

//Floating Subtract (Double-Precision)
//frD=frA-frB
static inline void ppc_fsubx(u32 D,u32 A,u32 B,u32 Rc)
{
	ppc_emit( 0xfc000028 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)Rc)<<0) );
}


//fsubsx,111011,D<5>,A<5>,B<5>,0000010100,Rc<1>

//Floating Subtract Single
//frD=frA-frB
static inline void ppc_fsubsx(u32 D,u32 A,u32 B,u32 Rc)
{
	ppc_emit( 0xec000028 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)Rc)<<0) );
}


//icbi,01111100000,A<5>,B<5>,11110101100

//Instruction Cache Block Invalidate
//EA is the sum (rA|0) + (rB)
static inline void ppc_icbi(u32 A,u32 B)
{
	ppc_emit( 0x7c0007ac | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//isync,01001100000000000000000100101100

//Instruction Synchronize
static inline void ppc_isync()
{
	ppc_emit( 0x4c00012c );
}


//lbz,100010,D<5>,A<5>,d<16>

//Load Byte and Zero
//EA is the sum (rA|0) + d
static inline void ppc_lbz(u32 D,u32 A,u32 d)
{
	ppc_emit( 0x88000000 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0xffff & (u32)d)<<0) );
}


//lbzx,011111,D<5>,A<5>,B<5>,00010101110

//Load Byte and Zero Indexed
//EA is the sum (rA|0) + (rB)
static inline void ppc_lbzx(u32 D,u32 A,u32 B)
{
	ppc_emit( 0x7c0000ae | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//lbzu,100011,D<5>,A<5>,d<16>

//Load Byte and Zero with Update (rA!=0,rD!=rA)
//EA is the sum (rA) + d
//rA=EA
static inline void ppc_lbzu(u32 D,u32 A,u32 d)
{
	ppc_emit( 0x8c000000 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0xffff & (u32)d)<<0) );
}


//lbzux,011111,D<5>,A<5>,B<5>,00011101110

//Load Byte and Zero with Update Indexed (rA!=0,rD!=rA)
//EA is the sum (rA) + (rB)
//rA=EA
static inline void ppc_lbzux(u32 D,u32 A,u32 B)
{
	ppc_emit( 0x7c0000ee | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//lfd<16>,110010,D<5>,A<5>,d<16>

//Load Floating-Point Double
//EA is the sum (rA|0) + d
static inline void ppc_lfd(u32 D,u32 A,u32 d)
{
	ppc_emit( 0xc8000000 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0xffff & (u32)d)<<0) );
}


//lfdx,011111,D<5>,A<5>,B<5>,10010101110

//Load Floating-Point Double Indexed
//EA is the sum (rA|0) + (rB)
static inline void ppc_lfdx(u32 D,u32 A,u32 B)
{
	ppc_emit( 0x7c0004ae | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//lfd<16>u,110011,D<5>,A<5>,d<16>

//Load Floating-Point Double (rA!=0)
//EA is the sum (rA) + d
//rA=EA
static inline void ppc_lfdu(u32 D,u32 A,u32 d)
{
	ppc_emit( 0xcc000000 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0xffff & (u32)d)<<0) );
}


//lfdux,011111,D<5>,A<5>,B<5>,10011101110

//Load Floating-Point Double Indexed (rA!=0)
//EA is the sum (rA|0) + (rB)
//rA=EA
static inline void ppc_lfdux(u32 D,u32 A,u32 B)
{
	ppc_emit( 0x7c0004ee | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//lfs,110000,D<5>,A<5>,d<16>

//Load Floating-Point Single
//EA is the sum (rA|0) + d
static inline void ppc_lfs(u32 D,u32 A,u32 d)
{
	ppc_emit( 0xc0000000 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0xffff & (u32)d)<<0) );
}


//lfsx,011111,D<5>,A<5>,B<5>,10000101110

//Load Floating-Point Single Indexed
//EA is the sum (rA|0) + (rB)
static inline void ppc_lfsx(u32 D,u32 A,u32 B)
{
	ppc_emit( 0x7c00042e | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//lfsux,011111,D<5>,A<5>,B<5>,10001101110

//Load Floating-Point Single with Update Indexed  (rA!=0)
//EA = (rA) + (rB)
//rA = EA
static inline void ppc_lfsux(u32 D,u32 A,u32 B)
{
	ppc_emit( 0x7c00046e | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//lfsu,110001,D<5>,A<5>,d<16>

//Load Floating-Point Single with Update (rA!=0)
//EA is the sum (rA) + d
//rA=EA
static inline void ppc_lfsu(u32 D,u32 A,u32 d)
{
	ppc_emit( 0xc4000000 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0xffff & (u32)d)<<0) );
}


//lha,101010,D<5>,A<5>,d<16>

//Load Half Word Algebraic
//EA is the sum (rA|0) + d
static inline void ppc_lha(u32 D,u32 A,u32 d)
{
	ppc_emit( 0xa8000000 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0xffff & (u32)d)<<0) );
}


//lhax,011111,D<5>,A<5>,B<5>,01010101110

//Load Half Word Algebraic Indexed
//EA is the sum (rA|0) + (rB)
static inline void ppc_lhax(u32 D,u32 A,u32 B)
{
	ppc_emit( 0x7c0002ae | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//lhau,101011,D<5>,A<5>,d<16>

//Load Half Word Algebraic with Update
//EA is the sum (rA) + d
static inline void ppc_lhau(u32 D,u32 A,u32 d)
{
	ppc_emit( 0xac000000 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0xffff & (u32)d)<<0) );
}


//lhaux,011111,D<5>,A<5>,B<5>,01011101110

//Load Half Word Algebraic with Update Indexed
//EA is the sum (rA) + (rB)
static inline void ppc_lhaux(u32 D,u32 A,u32 B)
{
	ppc_emit( 0x7c0002ee | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//lhbrx,011111,D<5>,A<5>,B<5>,11000101100

//Load Half Word Byte-Reverse Indexed
//EA is the sum (rA|0) + (rB)
static inline void ppc_lhbrx(u32 D,u32 A,u32 B)
{
	ppc_emit( 0x7c00062c | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//lhz,101000,D<5>,A<5>,d<16>

//Load Half Word and Zero
//EA is the sum (rA|0) + d
static inline void ppc_lhz(u32 D,u32 A,u32 d)
{
	ppc_emit( 0xa0000000 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0xffff & (u32)d)<<0) );
}


//lhzx,011111,D<5>,A<5>,B<5>,01000101110

//Load Half Word and Zero Indexed
//EA is the sum (rA|0) + (rB)
static inline void ppc_lhzx(u32 D,u32 A,u32 B)
{
	ppc_emit( 0x7c00022e | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//lhzux,011111,D<5>,A<5>,B<5>,01001101110

//Load Half Word and Zero with Update Indexed (rA!=0, rA!=rD)
//EA is the sum (rA) + (rB)
static inline void ppc_lhzux(u32 D,u32 A,u32 B)
{
	ppc_emit( 0x7c00026e | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//lhzu,101001,D<5>,A<5>,d<16>

//Load Half Word and Zero with Update (rA!=0, rA!=rD)
//EA is the sum (rA) + d
static inline void ppc_lhzu(u32 D,u32 A,u32 d)
{
	ppc_emit( 0xa4000000 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0xffff & (u32)d)<<0) );
}


//lmw,101110,D<5>,A<5>,d<16>

//Load Multiple Word
//EA is the sum (rA|0) + d
static inline void ppc_lmw(u32 D,u32 A,u32 d)
{
	ppc_emit( 0xb8000000 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0xffff & (u32)d)<<0) );
}


//lswx,011111,D<5>,A<5>,B<5>,10000101010

//Load String Word Indexed
//EA is the sum (rA|0) + (rB)
static inline void ppc_lswx(u32 D,u32 A,u32 B)
{
	ppc_emit( 0x7c00042a | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//lswi,011111,D<5>,A<5>,NB<5>,10010101010

//Load String Word Immediate
//EA is (rA|0)
static inline void ppc_lswi(u32 D,u32 A,u32 NB)
{
	ppc_emit( 0x7c0004aa | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)NB)<<11) );
}


//lwarx,011111,D<5>,A<5>,B<5>,00000101000

//Load Word and Reserve Indexed
//EA is the sum (rA|0) + (rB)
static inline void ppc_lwarx(u32 D,u32 A,u32 B)
{
	ppc_emit( 0x7c000028 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//lwbrx,011111,D<5>,A<5>,B<5>,10000101100

//Load Word Byte-Reverse Indexed
//EA is the sum (rA|0) + rB
static inline void ppc_lwbrx(u32 D,u32 A,u32 B)
{
	ppc_emit( 0x7c00042c | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//lwz,100000,D<5>,A<5>,d<16>

//Load Word and Zero
//EA is the sum (rA|0) + d
static inline void ppc_lwz(u32 D,u32 A,u32 d)
{
	ppc_emit( 0x80000000 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0xffff & (u32)d)<<0) );
}


//lwzx,011111,D<5>,A<5>,B<5>,00000101110

//Load Word and Zero Indexed
//EA is the sum (rA|0) + (rB)
static inline void ppc_lwzx(u32 D,u32 A,u32 B)
{
	ppc_emit( 0x7c00002e | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//lwzu,100001,D<5>,A<5>,d<16>

//Load Word and Zero with Update (rA != 0, rA != rD)
//EA is the sum (rA) + d
//rA = EA
static inline void ppc_lwzu(u32 D,u32 A,u32 d)
{
	ppc_emit( 0x84000000 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0xffff & (u32)d)<<0) );
}


//lwzux,011111,D<5>,A<5>,B<5>,00001101110

//Load Word and Zero with Update Indexed (rA != 0, rA != rD)
//EA is the sum (rA) + (rB)
//rA=EA
static inline void ppc_lwzux(u32 D,u32 A,u32 B)
{
	ppc_emit( 0x7c00006e | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//mcrf,010011,crfD<3>,00,crfS<3>,000000000000000000

//Move Condition Register Field
//CR[crfD] = CR[crfS]
static inline void ppc_mcrf(u32 crfD,u32 crfS)
{
	ppc_emit( 0x4c000000 | ((0x7 & (u32)crfD)<<23) | ((0x7 & (u32)crfS)<<18) );
}


//mcrfs,111111,crfD<3>,00,crfS<3>,000000000010000000

//Move to Condition Register from FPSCR
//CR[crfD] = FPSCR[crfS]
static inline void ppc_mcrfs(u32 crfD,u32 crfS)
{
	ppc_emit( 0xfc000080 | ((0x7 & (u32)crfD)<<23) | ((0x7 & (u32)crfS)<<18) );
}


//mcrxr,011111,crfD<3>,00000000000010000000000

//Move to Condition Register from XER
//CR[crfD] = XER[0:3]
static inline void ppc_mcrxr(u32 crfD)
{
	ppc_emit( 0x7c000400 | ((0x7 & (u32)crfD)<<23) );
}


//mfcr,011111,D<5>,000000000000000100110

//Move from Condition Register
//rD = CR
static inline void ppc_mfcr(u32 D)
{
	ppc_emit( 0x7c000026 | ((0x1f & (u32)D)<<21) );
}


//mffsx,111111,D<5>,00000000001001000111,Rc<1>

//Move from FPSCR
//frD[32:63] = FPSCR
static inline void ppc_mffsx(u32 D,u32 Rc)
{
	ppc_emit( 0xfc00048e | ((0x1f & (u32)D)<<21) | ((0x1 & (u32)Rc)<<0) );
}


//mfmsr,011111,D<5>,000000000000010100110

//Move from Machine State Register
//rD = MSR
static inline void ppc_mfmsr(u32 D)
{
	ppc_emit( 0x7c0000a6 | ((0x1f & (u32)D)<<21) );
}


//mfspr<10>,011111,D<5>,spr<10>,01010100110

//Move from Special-Purpose Register
//rD = SPR[n]
static inline void ppc_mfspr(u32 D,u32 spr)
{
	ppc_emit( 0x7c0002a6 | ((0x1f & (u32)D)<<21) | ((0x3ff & (u32)spr)<<11) );
}


//mfsr,011111,D<5>,0,SR<4>,0000010010100110

//Move from Segment Register
//rD = SEGREG(SR)
static inline void ppc_mfsr(u32 D,u32 SR)
{
	ppc_emit( 0x7c0004a6 | ((0x1f & (u32)D)<<21) | ((0xf & (u32)SR)<<16) );
}


//mfsrin,011111,D<5>,00000,B<5>,10100100110

//Move from Segment Register Indirect
//rD = SEGREG(rB[03])
static inline void ppc_mfsrin(u32 D,u32 B)
{
	ppc_emit( 0x7c000526 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)B)<<11) );
}


//mftb,011111,D<5>,tbr<10>,01011100110

//Move from Time Base
//rD = TBR[tbr]
static inline void ppc_mftb(u32 D,u32 tbr)
{
	ppc_emit( 0x7c0002e6 | ((0x1f & (u32)D)<<21) | ((0x3ff & (u32)tbr)<<11) );
}


//mtcrf,011111,S<5>,0,CRM<8>,000100100000

//Move to Condition Register Fields
//CR = rS & mask | CR &~mask
static inline void ppc_mtcrf(u32 CRM,u32 S)
{
	ppc_emit( 0x7c000120 | ((0xff & (u32)CRM)<<12) | ((0x1f & (u32)S)<<21) );
}


//mtfsb0x,111111,crbD<5>,00000000000001000110,Rc<1>

//Move to FPSCR Bit 0
//FPSRC(crbD) = 0
static inline void ppc_mtfsb0x(u32 crbD,u32 Rc)
{
	ppc_emit( 0xfc00008c | ((0x1f & (u32)crbD)<<21) | ((0x1 & (u32)Rc)<<0) );
}


//mtfsb1x,111111,crbD<5>,00000000000000100110,Rc<1>

//Move to FPSCR Bit 1
//FPSRC(crbD) = 1
static inline void ppc_mtfsb1x(u32 crbD,u32 Rc)
{
	ppc_emit( 0xfc00004c | ((0x1f & (u32)crbD)<<21) | ((0x1 & (u32)Rc)<<0) );
}


//mtfsfx,1111110,FM<8>,0,B<5>,1011000111,Rc<1>

//Move to FPSCR Fields
static inline void ppc_mtfsfx(u32 FM,u32 B,u32 Rc)
{
	ppc_emit( 0xfc00058e | ((0xff & (u32)FM)<<17) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)Rc)<<0) );
}


//mtfsfix,111111,crfD<3>,0000000,IMM<4>,00010000110,Rc<1>

//Move to FPSCR Field Immediate
//FPSCR[crfD] = IMM
static inline void ppc_mtfsfix(u32 crfD,u32 IMM,u32 Rc)
{
	ppc_emit( 0xfc00010c | ((0x7 & (u32)crfD)<<23) | ((0xf & (u32)IMM)<<12) | ((0x1 & (u32)Rc)<<0) );
}


//mtmsr,011111,S<5>,000000000000100100100

//Move to Machine State Register
//MSR = (rS)
static inline void ppc_mtmsr(u32 S)
{
	ppc_emit( 0x7c000124 | ((0x1f & (u32)S)<<21) );
}


//mtspr<10>,011111,S<5>,spr<10>,01110100110

//Move to Special-Purpose Register
//SPR[spr] = (rS)
static inline void ppc_mtspr(u32 spr,u32 S)
{
	ppc_emit( 0x7c0003a6 | ((0x3ff & (u32)spr)<<11) | ((0x1f & (u32)S)<<21) );
}


//mtsr,011111,S<5>,0,S<5>R<4>,0000000110100100

//Move to Segment Register
//SEGREG(SR) = (rS)
static inline void ppc_mtsr(u32 SR,u32 S)
{
	ppc_emit( 0x7c0001a4 | ((0xf & (u32)SR)<<16) | ((0x1f & (u32)S)<<21) );
}


//mtsrin,011111,S<5>,00000,B<5>,00111100100

//Move to Segment Register Indirect
//SEGREG(rB[0-3]) = (rS)
static inline void ppc_mtsrin(u32 B,u32 S)
{
	ppc_emit( 0x7c0001e4 | ((0x1f & (u32)B)<<11) | ((0x1f & (u32)S)<<21) );
}


//mulhwx,011111,D<5>,A<5>,B<5>,0001001011,Rc<1>

//Multiply High Word
//prod[0-63] = rA * rB
//rD = prod[high bits]
static inline void ppc_mulhwx(u32 D,u32 A,u32 B,u32 Rc)
{
	ppc_emit( 0x7c000096 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)Rc)<<0) );
}


//mulhwux,011111,D<5>,A<5>,B<5>,0000001011,Rc<1>

//Multiply High Word Unsigned
//prod[063] = (rA) * (rB)
//rD = prod[high bits]
static inline void ppc_mulhwux(u32 D,u32 A,u32 B,u32 Rc)
{
	ppc_emit( 0x7c000016 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)Rc)<<0) );
}


//mulli,000111,D<5>,A<5>,SIMM<16>

//Multiply Low Immediate
//prod[048] = (rA) * SIMM
//rD = prod[16-48]
static inline void ppc_mulli(u32 D,u32 A,u32 SIMM)
{
	ppc_emit( 0x1c000000 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0xffff & (u32)SIMM)<<0) );
}


//mullwx,011111,D<5>,A<5>,B<5>,OE<1>,011101011,Rc<1>

//Multiply Low Word
//prod[048] = (rA) * (rB)
//rD = prod[16-48]
static inline void ppc_mullwx(u32 D,u32 A,u32 B,u32 OE,u32 Rc)
{
	ppc_emit( 0x7c0001d6 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)OE)<<10) | ((0x1 & (u32)Rc)<<0) );
}


//nandx,011111,S<5>,A<5>,B<5>,0111011100,Rc<1>

//NAnd
//rA = ~ ((rS) & (rB))
static inline void ppc_nandx(u32 A,u32 S,u32 B,u32 Rc)
{
	ppc_emit( 0x7c0003b8 | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)Rc)<<0) );
}


//negx,011111,D<5>,A<5>,00000,OE<1>,001101000,Rc<1>

//rD= ~ (rA) + 1
static inline void ppc_negx(u32 D,u32 A,u32 OE,u32 Rc)
{
	ppc_emit( 0x7c0000d0 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1 & (u32)OE)<<10) | ((0x1 & (u32)Rc)<<0) );
}


//norx,011111,S<5>,A<5>,B<5>,0001111100,Rc<1>

//Nor
//rA = ~ ((rS) | (rB))
static inline void ppc_norx(u32 A,u32 S,u32 B,u32 Rc)
{
	ppc_emit( 0x7c0000f8 | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)Rc)<<0) );
}


//orx,011111,S<5>,A<5>,B<5>,0110111100,Rc<1>

//Or
//rA = (rS) | (rB)
static inline void ppc_orx(u32 A,u32 S,u32 B,u32 Rc)
{
	ppc_emit( 0x7c000378 | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)Rc)<<0) );
}


//orcx,011111,S<5>,A<5>,B<5>,0110011100,Rc<1>

//Or with Complement
//rA = (rS) | ~ (rB)
static inline void ppc_orcx(u32 A,u32 S,u32 B,u32 Rc)
{
	ppc_emit( 0x7c000338 | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)Rc)<<0) );
}


//ori,011000,S<5>,A<5>,UIMM<16>

//Or Immediate
//rA = (rS) | UIMM
static inline void ppc_ori(u32 A,u32 S,u32 UIMM)
{
	ppc_emit( 0x60000000 | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)S)<<21) | ((0xffff & (u32)UIMM)<<0) );
}


//oris,011001,S<5>,A<5>,UIMM<16>

//OR Immediate Shifted
//rA = (rS) | UIMM<<16
static inline void ppc_oris(u32 A,u32 S,u32 UIMM)
{
	ppc_emit( 0x64000000 | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)S)<<21) | ((0xffff & (u32)UIMM)<<0) );
}


//ps_abs,000100,D<5>,00000,B<5>,0100001000,Rc<1>

//Paired Single Absolute Value
//frD = fabs(frB)
static inline void ppc_ps_abs(u32 D,u32 B,u32 Rc)
{
	ppc_emit( 0x10000210 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)Rc)<<0) );
}


//ps_add,000100,D<5>,A<5>,B<5>,0000010101,Rc<1>

//Paired Single Add
//frD = frA+ frB
static inline void ppc_ps_add(u32 D,u32 A,u32 B,u32 Rc)
{
	ppc_emit( 0x1000002a | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)Rc)<<0) );
}


//ps_cmpo0,000100,crfD<3>,00,A<5>,B<5>,00001000000

//Paired Singles Compare Ordered High
//CR[crfD]=cmpord(rfA,rfB)
static inline void ppc_ps_cmpo0(u32 crfD,u32 A,u32 B)
{
	ppc_emit( 0x10000040 | ((0x7 & (u32)crfD)<<23) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//ps_cmpo1,000100,crfD<3>,00,A<5>,B<5>,00011000000

//Paired Singles Compare Ordered Low
//CR[crfD]=cmpord(rfA,rfB)
static inline void ppc_ps_cmpo1(u32 crfD,u32 A,u32 B)
{
	ppc_emit( 0x100000c0 | ((0x7 & (u32)crfD)<<23) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//ps_cmpu0,000100,crfD<3>,00,A<5>,B<5>,00000000000

//Paired Singles Compare Unordered High
//CR[crfD]=cmpun(rfA,rfB)
static inline void ppc_ps_cmpu0(u32 crfD,u32 A,u32 B)
{
	ppc_emit( 0x10000000 | ((0x7 & (u32)crfD)<<23) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//ps_cmpu1,000100,crfD<3>,00,A<5>,B<5>,00010000000

//Paired Singles Compare Unordered Low
//CR[crfD]=cmpun(rfA,rfB)
static inline void ppc_ps_cmpu1(u32 crfD,u32 A,u32 B)
{
	ppc_emit( 0x10000080 | ((0x7 & (u32)crfD)<<23) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//ps_div,000100,D<5>,A<5>,B<5>,0000010010,Rc<1>

//Paired Single Divide
//frD(ps*) = frA(ps*) / frB(ps*)
static inline void ppc_ps_div(u32 D,u32 A,u32 B,u32 Rc)
{
	ppc_emit( 0x10000024 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)Rc)<<0) );
}


//ps_madd,000100,D<5>,A<5>,B<5>,C<5>,11101,Rc<1>

//Paired Single Multiply-Add
//frD(ps*) = [frA(ps*) * frC(ps*)] + frB(ps*)
static inline void ppc_ps_madd(u32 D,u32 A,u32 B,u32 C,u32 Rc)
{
	ppc_emit( 0x1000003a | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1f & (u32)C)<<6) | ((0x1 & (u32)Rc)<<0) );
}


//ps_madds0,000100,D<5>,A<5>,B<5>,C<5>,01110,Rc<1>

//Paired Single Multiply-Add Scalar high
//frD(ps0) = [frA(ps0) * frC(ps0)] + frB(ps0)
//frD(ps1) = [frA(ps1) * frC(ps0)] + frB(ps1)
static inline void ppc_ps_madds0(u32 D,u32 A,u32 B,u32 C,u32 Rc)
{
	ppc_emit( 0x1000001c | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1f & (u32)C)<<6) | ((0x1 & (u32)Rc)<<0) );
}


//ps_madds1,000100,D<5>,A<5>,B<5>,C<5>,01111,Rc<1>

//Paired Single Multiply-Add Scalar low
//frD(ps0) = [frA(ps0) * frC(ps1)] + frB(ps0)
//frD(ps1) = [frA(ps1) * frC(ps1)] + frB(ps1)
static inline void ppc_ps_madds1(u32 D,u32 A,u32 B,u32 C,u32 Rc)
{
	ppc_emit( 0x1000001e | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1f & (u32)C)<<6) | ((0x1 & (u32)Rc)<<0) );
}


//ps_merge00,000100,D<5>,A<5>,B<5>,1000010000,Rc<1>

//Paired Single MERGE high
//frD(ps0) = frA(ps0)
//frD(ps1) = frB(ps0)
static inline void ppc_ps_merge00(u32 D,u32 A,u32 B,u32 Rc)
{
	ppc_emit( 0x10000420 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)Rc)<<0) );
}


//ps_merge01,000100,D<5>,A<5>,B<5>,1000110000,Rc<1>

//Paired Single MERGE direct
//frD(ps0) = frA(ps0)
//frD(ps1) = frB(ps1)
static inline void ppc_ps_merge01(u32 D,u32 A,u32 B,u32 Rc)
{
	ppc_emit( 0x10000460 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)Rc)<<0) );
}


//ps_merge10,000100,D<5>,A<5>,B<5>,1001010101,Rc<1>

//Paired Single MERGE swapped
//frD(ps0) = frA(ps1)
//frD(ps1) = frB(ps0)
static inline void ppc_ps_merge10(u32 D,u32 A,u32 B,u32 Rc)
{
	ppc_emit( 0x100004aa | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)Rc)<<0) );
}


//ps_merge11,000100,D<5>,A<5>,B<5>,1001110000,Rc<1>

//Paired Single MERGE low
//frD(ps0) = frA(ps1)
//frD(ps1) = frB(ps1)
static inline void ppc_ps_merge11(u32 D,u32 A,u32 B,u32 Rc)
{
	ppc_emit( 0x100004e0 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)Rc)<<0) );
}


//ps_mr,000100,D<5>,00000,B<5>,0001001000,Rc<1>

//Paired Single Move Register
//frD(ps0) = frB(ps0)
//frD(ps1) = frB(ps1)
static inline void ppc_ps_mr(u32 D,u32 B,u32 Rc)
{
	ppc_emit( 0x10000090 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)Rc)<<0) );
}


//ps_msub,000100,D<5>,A<5>,B<5>,C<5>,11100,Rc<1>

//Paired Single Multiply-Subtract
//frD(ps0) = [frA(ps0) * frC(ps0)] - frB(ps0)
//frD(ps1) = [frA(ps1) * frC(ps1)] - frB(ps1)
static inline void ppc_ps_msub(u32 D,u32 A,u32 B,u32 C,u32 Rc)
{
	ppc_emit( 0x10000038 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1f & (u32)C)<<6) | ((0x1 & (u32)Rc)<<0) );
}


//ps_mul,000100,D<5>,A<5>,00000,C<5>,11001,Rc<1>

//Paired Single Multiply
//frD(ps0) = frA(ps0) * frC(ps0)
//frD(ps1) = frA(ps1) * frC(ps1)
static inline void ppc_ps_mul(u32 D,u32 A,u32 C,u32 Rc)
{
	ppc_emit( 0x10000032 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)C)<<6) | ((0x1 & (u32)Rc)<<0) );
}


//ps_muls0,000100,D<5>,A<5>,00000,C<5>,01100,Rc<1>

//Paired Single Multiply Scalar high
//frD(ps0) = frA(ps0) * frC(ps0)
//frD(ps1) = frA(ps1) * frC(ps0)
static inline void ppc_ps_muls0(u32 D,u32 A,u32 C,u32 Rc)
{
	ppc_emit( 0x10000018 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)C)<<6) | ((0x1 & (u32)Rc)<<0) );
}


//ps_muls1,000100,D<5>,A<5>,00000,C<5>,01101,Rc<1>

//Paired Single Multiply Scalar low
//frD(ps0) = frA(ps0) * frC(ps1)
//frD(ps1) = frA(ps1) * frC(ps1)
static inline void ppc_ps_muls1(u32 D,u32 A,u32 C,u32 Rc)
{
	ppc_emit( 0x1000001a | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)C)<<6) | ((0x1 & (u32)Rc)<<0) );
}


//ps_nabs,000100,D<5>,00000,B<5>,0010001000,Rc<1>

//Paired Single Negative Absolute Value
//frD(ps0) =-fabs(frB(ps0))
//frD(ps1) =-fabs(frB(ps1))
static inline void ppc_ps_nabs(u32 D,u32 B,u32 Rc)
{
	ppc_emit( 0x10000110 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)Rc)<<0) );
}


//ps_neg,000100,D<5>,00000,B<5>,0000101000,Rc<1>

//Paired Single Negate
//frD(ps0) =-frB(ps0)
//frD(ps1) =-frB(ps1)
static inline void ppc_ps_neg(u32 D,u32 B,u32 Rc)
{
	ppc_emit( 0x10000050 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)Rc)<<0) );
}


//ps_nmadd,000100,D<5>,A<5>,B<5>,C<5>,11111,Rc<1>

//Paired Single Negative Multiply-Add
//frD(ps0) = -[frA(ps0) * frC(ps0) + frB(ps0) ]
//frD(ps1) = -[frA(ps1) * frC(ps1) + frB(ps1) ]
static inline void ppc_ps_nmadd(u32 D,u32 A,u32 B,u32 C,u32 Rc)
{
	ppc_emit( 0x1000003e | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1f & (u32)C)<<6) | ((0x1 & (u32)Rc)<<0) );
}


//ps_nmsub,000100,D<5>,A<5>,B<5>,C<5>,11110,Rc<1>

//Paired Single Negative Multiply-Subtract
//frD(ps0) = -[frA(ps0) * frC(ps0) - frB(ps0) ]
//frD(ps1) = -[frA(ps1) * frC(ps1) - frB(ps1) ]
static inline void ppc_ps_nmsub(u32 D,u32 A,u32 B,u32 C,u32 Rc)
{
	ppc_emit( 0x1000003c | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1f & (u32)C)<<6) | ((0x1 & (u32)Rc)<<0) );
}


//ps_res,000100,D<5>,00000,B<5>,0000011000,Rc<1>

//Paired Single Reciprocal Estimate
//frD(ps0) = estimate(1/frB(ps0))
//frD(ps1) = estimate(1/frB(ps1))
static inline void ppc_ps_res(u32 D,u32 B,u32 Rc)
{
	ppc_emit( 0x10000030 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)Rc)<<0) );
}


//ps_rsqrte,000100,D<5>,00000,B<5>,0000011010,Rc<1>

//Paired Single Reciprocal Estimate
//frD(ps0) = estimate(1/sqrt(frB(ps0)))
//frD(ps1) = estimate(1/sqrt(frB(ps1)))
static inline void ppc_ps_rsqrte(u32 D,u32 B,u32 Rc)
{
	ppc_emit( 0x10000034 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)Rc)<<0) );
}


//ps_sel,000100,D<5>,A<5>,B<5>,C<5>,10111,Rc<1>

//Paired Single Select
//frD(ps*)=frA(ps*)>=0?frC(ps*):frB(ps*)
static inline void ppc_ps_sel(u32 D,u32 A,u32 B,u32 C,u32 Rc)
{
	ppc_emit( 0x1000002e | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1f & (u32)C)<<6) | ((0x1 & (u32)Rc)<<0) );
}


//ps_sub,000100,D<5>,A<5>,B<5>,0000010100,Rc<1>

//Paired Single Subtract
//frD(ps0) = frA(ps0) - frB(ps0)
//frD(ps1) = frA(ps1) - frB(ps1)
static inline void ppc_ps_sub(u32 D,u32 A,u32 B,u32 Rc)
{
	ppc_emit( 0x10000028 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)Rc)<<0) );
}


//ps_sum0,000100,D<5>,A<5>,B<5>,C<5>,01010,Rc<1>

//Paired Single vector SUM high
//frD(ps0) = frA(ps0) + frB(ps1)
//frD(ps1) = frC(ps1)
static inline void ppc_ps_sum0(u32 D,u32 A,u32 B,u32 C,u32 Rc)
{
	ppc_emit( 0x10000014 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1f & (u32)C)<<6) | ((0x1 & (u32)Rc)<<0) );
}


//ps_sum1,000100,D<5>,A<5>,B<5>,C<5>,01011,Rc<1>

//Paired Single vector SUM low
//frD(ps0) = frC(ps0)
//frD(ps1) = frA(ps0) + frB(ps1)
static inline void ppc_ps_sum1(u32 D,u32 A,u32 B,u32 C,u32 Rc)
{
	ppc_emit( 0x10000016 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1f & (u32)C)<<6) | ((0x1 & (u32)Rc)<<0) );
}


//psq_l,111000,D<5>,A<5>,w<1>,i<3>,dpsq<12>

//Paired Single Quantized Load
static inline void ppc_psq_l(u32 D,u32 A,u32 w,u32 i,u32 dpsq)
{
	ppc_emit( 0xe0000000 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1 & (u32)w)<<15) | ((0x7 & (u32)i)<<12) | ((0xfff & (u32)dpsq)<<0) );
}


//psq_lx,000100,D<5>,A<5>,B<5>,w<1>,i<3>,0001100

//Paired Single Quantized Load Indexed
static inline void ppc_psq_lx(u32 D,u32 A,u32 B,u32 w,u32 i)
{
	ppc_emit( 0x1000000c | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)w)<<10) | ((0x7 & (u32)i)<<7) );
}


//psq_lu,111001,D<5>,A<5>,w<1>,i<3>,dpsq<12>

//Paired Single Quantized Load with Update
static inline void ppc_psq_lu(u32 D,u32 A,u32 w,u32 i,u32 dpsq)
{
	ppc_emit( 0xe4000000 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1 & (u32)w)<<15) | ((0x7 & (u32)i)<<12) | ((0xfff & (u32)dpsq)<<0) );
}


//psq_lux,000100,D<5>,A<5>,B<5>,w<1>,i<3>,1001100

//Paired Single Quantized Load with update Indexed
static inline void ppc_psq_lux(u32 D,u32 A,u32 B,u32 w,u32 i)
{
	ppc_emit( 0x1000004c | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)w)<<10) | ((0x7 & (u32)i)<<7) );
}


//psq_st,111100,S<5>,A<5>,w<1>,i<3>,dpsq<12>

//Paired Single Quantized Store
static inline void ppc_psq_st(u32 S,u32 A,u32 w,u32 i,u32 dpsq)
{
	ppc_emit( 0xf0000000 | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)A)<<16) | ((0x1 & (u32)w)<<15) | ((0x7 & (u32)i)<<12) | ((0xfff & (u32)dpsq)<<0) );
}


//psq_stx,000100,S<5>,A<5>,B<5>,w<1>,i<3>,0001110

//Paired Single Quantized Store Indexed
static inline void ppc_psq_stx(u32 S,u32 A,u32 B,u32 w,u32 i)
{
	ppc_emit( 0x1000000e | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)w)<<10) | ((0x7 & (u32)i)<<7) );
}


//psq_stu,111101,S<5>,A<5>,w<1>,i<3>,dpsq<12>

//Paired Single Quantized Store with update
static inline void ppc_psq_stu(u32 S,u32 A,u32 w,u32 i,u32 dpsq)
{
	ppc_emit( 0xf4000000 | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)A)<<16) | ((0x1 & (u32)w)<<15) | ((0x7 & (u32)i)<<12) | ((0xfff & (u32)dpsq)<<0) );
}


//psq_stux,000100,S<5>,A<5>,B<5>,w<1>,i<3>,1001110

//Paired Single Quantized Store with update Indexed
static inline void ppc_psq_stux(u32 S,u32 A,u32 B,u32 w,u32 i)
{
	ppc_emit( 0x1000004e | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)w)<<10) | ((0x7 & (u32)i)<<7) );
}


//rfi,01001100000000000000000001100100

//Return from Interrupt
static inline void ppc_rfi()
{
	ppc_emit( 0x4c000064 );
}


//rlwimix,010100,S<5>,A<5>,S<5>H,MB<5>,ME<5>,Rc<1>

//Rotate Left Word Immediate then Mask Insert
static inline void ppc_rlwimix(u32 A,u32 S,u32 SH,u32 MB,u32 ME,u32 Rc)
{
	ppc_emit( 0x50000000 | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)SH)<<11) | ((0x1f & (u32)MB)<<6) | ((0x1f & (u32)ME)<<1) | ((0x1 & (u32)Rc)<<0) );
}


//rlwinmx,010101,S<5>,A<5>,S<5>H,MB<5>,ME<5>,Rc<1>

//Rotate Left Word Immediate then AND with Mask
static inline void ppc_rlwinmx(u32 A,u32 S,u32 SH,u32 MB,u32 ME,u32 Rc)
{
	ppc_emit( 0x54000000 | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)SH)<<11) | ((0x1f & (u32)MB)<<6) | ((0x1f & (u32)ME)<<1) | ((0x1 & (u32)Rc)<<0) );
}


//rlwnmx,010111,S<5>,A<5>,B<5>,MB<5><5>,ME<5>,Rc<1>

//Rotate Left Word then AND with Mask
static inline void ppc_rlwnmx(u32 A,u32 S,u32 B,u32 MB,u32 ME,u32 Rc)
{
	ppc_emit( 0x5c000000 | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)B)<<11) | ((0x1f & (u32)MB)<<6) | ((0x1f & (u32)ME)<<1) | ((0x1 & (u32)Rc)<<0) );
}


//sc,01000100000000000000000000000010

//System Call
static inline void ppc_sc()
{
	ppc_emit( 0x44000002 );
}


//slwx,011111,S<5>,A<5>,B<5>,0000011000,Rc<1>

//Shift Left Word
//rA=rS<<rB[26:31]
static inline void ppc_slwx(u32 A,u32 S,u32 B,u32 Rc)
{
	ppc_emit( 0x7c000030 | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)Rc)<<0) );
}


//srawx,011111,S<5>,A<5>,B<5>,1100011000,Rc<1>

//Shift Right Algebraic Word
//rA=RS>>rB[26:31]
static inline void ppc_srawx(u32 A,u32 S,u32 B,u32 Rc)
{
	ppc_emit( 0x7c000630 | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)Rc)<<0) );
}


//srawix,011111,S<5>,A<5>,S<5>H,1100111000,Rc<1>

//Shift Right Algebraic Word Immediate
//rA=rS>>SH
static inline void ppc_srawix(u32 A,u32 S,u32 SH,u32 Rc)
{
	ppc_emit( 0x7c000670 | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)SH)<<11) | ((0x1 & (u32)Rc)<<0) );
}


//srwx,011111,S<5>,A<5>,B<5>,1000011000,Rc<1>

//Shift Right Word
//rA=rS>>rB[26:31]
static inline void ppc_srwx(u32 A,u32 S,u32 B,u32 Rc)
{
	ppc_emit( 0x7c000430 | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)Rc)<<0) );
}


//stb,100110,S<5>,A<5>,d<16>

//Store Byte
//EA is the sum (rA|0) + d
static inline void ppc_stb(u32 S,u32 A,u32 d)
{
	ppc_emit( 0x98000000 | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)A)<<16) | ((0xffff & (u32)d)<<0) );
}


//stbx,011111,S<5>,A<5>,B<5>,00110101110

//Store Byte Indexed
//EA is the sum (rA|0) + (rB)
static inline void ppc_stbx(u32 S,u32 A,u32 B)
{
	ppc_emit( 0x7c0001ae | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//stbu,100111,S<5>,A<5>,d<16>

//Store Byte with Update
//EA is the sum (rA) + d
//rA=EA
static inline void ppc_stbu(u32 S,u32 A,u32 d)
{
	ppc_emit( 0x9c000000 | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)A)<<16) | ((0xffff & (u32)d)<<0) );
}


//stbux,011111,S<5>,A<5>,B<5>,00111101110

//Store Byte with Update Indexed (rA!=0)
//EA is the sum (rA) + (rB).
//rA = EA
static inline void ppc_stbux(u32 S,u32 A,u32 B)
{
	ppc_emit( 0x7c0001ee | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//stfd<16>,110110,S<5>,A<5>,d<16>

//Store Floating-Point Double
//EA is the sum (rA|0) + d
static inline void ppc_stfd(u32 S,u32 A,u32 d)
{
	ppc_emit( 0xd8000000 | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)A)<<16) | ((0xffff & (u32)d)<<0) );
}


//stfdx,011111,S<5>,A<5>,B<5>,10110101110

//Store Floating-Point Double Indexed
//EA is the sum (rA|0) + rB
static inline void ppc_stfdx(u32 S,u32 A,u32 B)
{
	ppc_emit( 0x7c0005ae | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//stfd<16>u,110111,S<5>,A<5>,d<16>

//Store Floating-Point Double with Update
//EA is the sum (rA) + d
//rA=EA
static inline void ppc_stfdu(u32 S,u32 A,u32 d)
{
	ppc_emit( 0xdc000000 | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)A)<<16) | ((0xffff & (u32)d)<<0) );
}


//stfdux,011111,S<5>,A<5>,B<5>,10111101110

//Store Floating-Point Double with Update Indexed
//EA is the sum (rA) + (rB)
//rA=EA
static inline void ppc_stfdux(u32 S,u32 A,u32 B)
{
	ppc_emit( 0x7c0005ee | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//stfiwx,011111,S<5>,A<5>,B<5>,11110101110

//Store Floating-Point as Integer Word Indexed
//EA is the sum (rA|0) + (rB).
static inline void ppc_stfiwx(u32 S,u32 A,u32 B)
{
	ppc_emit( 0x7c0007ae | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//stfs,110100,S<5>,A<5>,d<16>

//Store Floating-Point Single
//EA is the sum (rA|0) + d
static inline void ppc_stfs(u32 S,u32 A,u32 d)
{
	ppc_emit( 0xd0000000 | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)A)<<16) | ((0xffff & (u32)d)<<0) );
}


//stfsx,011111,S<5>,A<5>,B<5>,10100101110

//Store Floating-Point Single Indexed
//EA is the sum (rA|0) + (rB)
static inline void ppc_stfsx(u32 S,u32 A,u32 B)
{
	ppc_emit( 0x7c00052e | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//stfsu,110101,S<5>,A<5>,d<16>

//Store Floating-Point Single (rA!=0)
//EA is the sum (rA) + d
//rA=EA
static inline void ppc_stfsu(u32 S,u32 A,u32 d)
{
	ppc_emit( 0xd4000000 | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)A)<<16) | ((0xffff & (u32)d)<<0) );
}


//stfsux,011111,S<5>,A<5>,B<5>,10101101110

//Store Floating-Point Single Indexed (rA!=0)
//EA is the sum (rA) + (rB)
//rA=EA
static inline void ppc_stfsux(u32 S,u32 A,u32 B)
{
	ppc_emit( 0x7c00056e | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//sth,101100,S<5>,A<5>,d<16>

//Store Half Word
//EA is the sum (rA|0) + d
static inline void ppc_sth(u32 S,u32 A,u32 d)
{
	ppc_emit( 0xb0000000 | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)A)<<16) | ((0xffff & (u32)d)<<0) );
}


//sthx,011111,S<5>,A<5>,B<5>,01100101110

//Store Half Word Indexed
//EA is the sum (rA|0) + (rB)
static inline void ppc_sthx(u32 S,u32 A,u32 B)
{
	ppc_emit( 0x7c00032e | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//sthbrx,011111,S<5>,A<5>,B<5>,11100101100

//Store Half Word Byte-Reverse Indexed
//EA is the sum (rA|0) + (rB)
static inline void ppc_sthbrx(u32 S,u32 A,u32 B)
{
	ppc_emit( 0x7c00072c | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//sthu,101101,S<5>,A<5>,d<16>

//Store Half Word with Update (rA!=0)
//EA is the sum (rA) + d
//rA=EA
static inline void ppc_sthu(u32 S,u32 A,u32 d)
{
	ppc_emit( 0xb4000000 | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)A)<<16) | ((0xffff & (u32)d)<<0) );
}


//sthux,011111,S<5>,A<5>,B<5>,01101101110

//Store Half Word with Update Indexed (rA!=0)
//EA is the sum (rA) + (rB)
//rA=EA
static inline void ppc_sthux(u32 S,u32 A,u32 B)
{
	ppc_emit( 0x7c00036e | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//stmw,101111,S<5>,A<5>,d<16>

//Store Multiple Word
//EA is the sum (rA|0) + d
static inline void ppc_stmw(u32 S,u32 A,u32 d)
{
	ppc_emit( 0xbc000000 | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)A)<<16) | ((0xffff & (u32)d)<<0) );
}


//stswx,011111,S<5>,A<5>,B<5>,10100101010

//Store String Word Indexed
//EA is the sum (rA|0) + (rB)
static inline void ppc_stswx(u32 S,u32 A,u32 B)
{
	ppc_emit( 0x7c00052a | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//stswi,011111,S<5>,A<5>,NB<5>,10110101010

//Store String Word Immediate
//EA is (rA|0)
static inline void ppc_stswi(u32 S,u32 A,u32 NB)
{
	ppc_emit( 0x7c0005aa | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)NB)<<11) );
}


//stw,100100,S<5>,A<5>,d<16>

//Store Word Indexed
//EA is the sum (rA|0) + (rB)
static inline void ppc_stw(u32 S,u32 A,u32 d)
{
	ppc_emit( 0x90000000 | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)A)<<16) | ((0xffff & (u32)d)<<0) );
}


//stwx,011111,S<5>,A<5>,B<5>,00100101110

//Store Word Indexed
//EA is the sum (rA|0) + (rB)
static inline void ppc_stwx(u32 S,u32 A,u32 B)
{
	ppc_emit( 0x7c00012e | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//stwbrx,011111,S<5>,A<5>,B<5>,10100101100

//Store Word Byte-Reverse Indexed
//EA is the sum (rA|0) + (rB)
static inline void ppc_stwbrx(u32 S,u32 A,u32 B)
{
	ppc_emit( 0x7c00052c | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//stwcx,011111,S<5>,A<5>,B<5>,00100101101

//Store Word Conditional Indexed
//EA is the sum (rA|0) + (rB)
static inline void ppc_stwcx(u32 S,u32 A,u32 B)
{
	ppc_emit( 0x7c00012d | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//stwu,100101,S<5>,A<5>,d<16>

//Store Word with Update (rA!=0)
//EA is the sum (rA) + d
//rA=EA
static inline void ppc_stwu(u32 S,u32 A,u32 d)
{
	ppc_emit( 0x94000000 | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)A)<<16) | ((0xffff & (u32)d)<<0) );
}


//stwux,011111,S<5>,A<5>,B<5>,00101101110

//Store Word with Update Indexed (rA!=0)
//EA is the sum (rA) + (rB)
//rA=EA
static inline void ppc_stwux(u32 S,u32 A,u32 B)
{
	ppc_emit( 0x7c00016e | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//subfx,011111,D<5>,A<5>,B<5>,OE<1>,000101000,Rc<1>

//Subtract From
//rD = ~ (rA) + (rB) + 1
static inline void ppc_subfx(u32 D,u32 A,u32 B,u32 OE,u32 Rc)
{
	ppc_emit( 0x7c000050 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)OE)<<10) | ((0x1 & (u32)Rc)<<0) );
}


//subfcx,011111,D<5>,A<5>,B<5>,OE<1>,000001000,Rc<1>

//Subtract from Carrying
//rD = ~ (rA) + (rB) + 1
static inline void ppc_subfcx(u32 D,u32 A,u32 B,u32 OE,u32 Rc)
{
	ppc_emit( 0x7c000010 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)OE)<<10) | ((0x1 & (u32)Rc)<<0) );
}


//subfex,011111,D<5>,A<5>,B<5>,OE<1>,010001000,Rc<1>

//Subtract from Extended
//rD = ~ (rA) + (rB) + XER[CA]
static inline void ppc_subfex(u32 D,u32 A,u32 B,u32 OE,u32 Rc)
{
	ppc_emit( 0x7c000110 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)OE)<<10) | ((0x1 & (u32)Rc)<<0) );
}


//subfic,001000,D<5>,A<5>,SIMM<16>

//Subtract from Immediate Carrying
//rD = ~ (rA) + EXTS(SIMM) + 1
static inline void ppc_subfic(u32 D,u32 A,u32 SIMM)
{
	ppc_emit( 0x20000000 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0xffff & (u32)SIMM)<<0) );
}


//subfmex,011111,D<5>,A<5>,00000,OE<1>,011101000,Rc<1>

//Subtract from Minus One Extended
//rD = ~ (rA) + XER[CA]  1
static inline void ppc_subfmex(u32 D,u32 A,u32 OE,u32 Rc)
{
	ppc_emit( 0x7c0001d0 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1 & (u32)OE)<<10) | ((0x1 & (u32)Rc)<<0) );
}


//subfzex,011111,D<5>,A<5>,00000,OE<1>,011001000,Rc<1>

//Subtract from Zero Extended
//rD = ~ (rA) + XER[CA]
static inline void ppc_subfzex(u32 D,u32 A,u32 OE,u32 Rc)
{
	ppc_emit( 0x7c000190 | ((0x1f & (u32)D)<<21) | ((0x1f & (u32)A)<<16) | ((0x1 & (u32)OE)<<10) | ((0x1 & (u32)Rc)<<0) );
}


//sync,01111100000000000000010010101100

//Synchronize
static inline void ppc_sync()
{
	ppc_emit( 0x7c0004ac );
}


//tlbie,0111110000000000,B<5>,01001100100

//Translation Lookaside Buffer Invalidate Entry
static inline void ppc_tlbie(u32 B)
{
	ppc_emit( 0x7c000264 | ((0x1f & (u32)B)<<11) );
}


//tlbsync,01111100000000000000010001101100

//TLB Synchronize
static inline void ppc_tlbsync()
{
	ppc_emit( 0x7c00046c );
}


//tw,011111,TO<5>,A<5>,B<5>,00000001000

//Trap Word
static inline void ppc_tw(u32 TO,u32 A,u32 B)
{
	ppc_emit( 0x7c000008 | ((0x1f & (u32)TO)<<21) | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)B)<<11) );
}


//twi,000011,TO<5>,A<5>,SIMM<16>

//Trap Word Immediate
static inline void ppc_twi(u32 TO,u32 A,u32 SIMM)
{
	ppc_emit( 0x0c000000 | ((0x1f & (u32)TO)<<21) | ((0x1f & (u32)A)<<16) | ((0xffff & (u32)SIMM)<<0) );
}


//xorx,011111,S<5>,A<5>,B<5>,0100111100,Rc<1>

//Xor
//rA = (rS) ^ (rB)
static inline void ppc_xorx(u32 A,u32 S,u32 B,u32 Rc)
{
	ppc_emit( 0x7c000278 | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)S)<<21) | ((0x1f & (u32)B)<<11) | ((0x1 & (u32)Rc)<<0) );
}


//xori,011010,S<5>,A<5>,UIMM<16>

//Xor Immediate
//rA = (rS) ^ UIMM
static inline void ppc_xori(u32 A,u32 S,u32 UIMM)
{
	ppc_emit( 0x68000000 | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)S)<<21) | ((0xffff & (u32)UIMM)<<0) );
}


//xoris,011011,S<5>,A<5>,UIMM<16>

//Xor Immediate Shifted
//rA = (rS) ^ UIMM
static inline void ppc_xoris(u32 A,u32 S,u32 UIMM)
{
	ppc_emit( 0x6c000000 | ((0x1f & (u32)A)<<16) | ((0x1f & (u32)S)<<21) | ((0xffff & (u32)UIMM)<<0) );
}

